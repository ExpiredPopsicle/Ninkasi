* TODO External data
** TODO Index-into for external data
** TODO Operator overloading for external data
** TODO GC callbacks
* TODO State serialization
** TODO Something for recognizing the same native function between save and load
Even if the address ends up different. (For serialized state
compatibility between different architectures, for example.)
** TODO Save
** TODO Load
* TODO Private/public header separation
* TODO Threading
** TODO Split stack, instruction pointer, and any other per-thread context stuff into a thread context object
** TODO Thread basic type
** TODO Mutex basic type
** TODO Active/inactive thread separation
** TODO Mutex locking
- Locking...
  - If mutex is locked...
    - Add thread to inactive thread list.
    - Add thread to list of threads to wake up on mutex unlock.
    - Otherwise...
      - Mark mutex as locked.
      - Maybe write down what thread locked it.
- Unlocking...
  - If there are threads in the locked list waiting to wake up...
    - Wake up the first thread that locked the mutex.
    - Mutex stays in locked state.
  - Otherwise...
    - Mark mutex as unlocked.

** TODO Thread sleeping
- Each item in a list of sleeping threads will have a tick count
  remaining until they wake up.
  - This time is relative to the item before it.
- Add thread to a list of sleeping threads
  - Insertion sort into the list of sleeping threads
    - Keep advancing through the list until we reach the end, or find
      a thread that is scheduled to sleep even longer than this one.
    - As we move through the list, subtract the wait time for each
      thread from this thread's wait time (so we end up with a
      relative sleep time).
    - Once we find a spot in the list, subtract the NEXT thread's
      sleep time from this thread's remaining sleep time. This will
      make the next thread positioned correctly relative to this one.
- Each tick...
  - We decrement the tick count on just the lowest thread in
    the list (because they're all relative to the one before).
  - While the tick count <= 0 on the head...
    - Remove head from sleeping thread list
    - Add head to active thread list

* DONE Strings
** DONE String garbage collection
* DONE Functions
** DONE VM functions
** DONE Native functions
*** DONE Native function userdata
*** DONE Check for duplicate native functions?
*** TODO Take out userdata
We'll just add one big userdata pointer to the VM, with a
serialization callback. This keeps us from having to manage userdata
lifetimes, because as of this writing, all the userdata is permanent
for the lifetime of the VM.
*** TODO Native function serialization
We may need a native function table of some sort, which must be
created before deserialization, compilation, or adding C functions.
Adding functions that are not in it, or deserializing and discovering
unregistered functions would probably have to be made an illegal
operation.
** DONE Calling VM functions from native functions.
* DONE For-loops
* DONE Increment and decrement operators
* DONE Comparison operators
** DONE Greater than
** DONE Less than
** DONE Greater than or equal
** DONE Less than or equal
** DONE Equal
** DONE Not equal
** DONE Equal with same type (===)
* DONE "Not" operator
* DONE % operator
* DONE && operator
* DONE || operator
* DONE Objects
** DONE Object garbage collection
** DONE Refactor objects to use hash tables.
** DONE Ability to clear values from an object.
** DONE External object handles.
* DONE Add generic hash function for Values.
* TODO Fuzz tester
* TODO Configurable limits
** DONE Memory usage
*** DONE Max strings
*** DONE Max string length
*** DONE Max stack size
*** DONE Max objects
*** DONE Max fields per object
*** DONE Max allocated memory
Remember to search for all the malloc, reallocs, and strdups.
**** DONE Correctly handle errors for everything
**** DONE Make a tester that randomly starts returning NULL and see if anything breaks.
** DONE Compiler recursion limit
** TODO Max thread count?
* TODO Documentation
Pfffffft

* TODO Can we double-buffer the GC list?
- May not be possible when we have to count external references.
* DONE foo.bar syntactic sugar.
'.' operator must be treated as postfix, I think. It's got the same
precedence level as other postfix operators, and it acts like [],
which is also postfix.

Look into the [] implementation to see how to do postfix operators
with secondary values.

a[b] is...
+ index into operator
  + a
  + b

a.b is...
+ index into operator
  + a
  + "b"

* DONE foo.bar() syntactic sugar.
We'll copy Lua here and insert a "self" parameter as the first
parameter here.

x.a(b, c) is...
+ function call (root)
  + index into operator
    + x
    + "a"
  + function call (param)
    + x
    + function call (param)
      + b
      + function call (param)
        + c
        + NULL

* TODO Deal with code duplication between string and object tables.
Mostly about the "hole" tracking stuff, unless we can genericize the
tables entirely. Would be easy with templates but whatever.

* DONE Maybe implement break.
- We'll have to keep track of what the most recent loop context is.
- Then add code to pop all of that out and jump to the end.
- Meaning we'll have to keep a list of jump points to update once the loop is over.
- Can store that all on the context object, I guess.
- Make sure we don't go outside the function while moving up the context stack!


* DONE Get rid of dump opcode.

* TODO Get rid of all the asserts that were ensuring contexts line up.
* TODO Make sure the error system has a standard way of reporting errors.
Looking at the errorState structure won't work.
** TODO Standardize catastrophic failure reporting
* DONE Looking up a nonexistant entry in an object should return nil and not create anything.
* TODO Catastrophe handling
** TODO Make sure the standard error reporting recognizes the out-of-memory special case.
** DONE (Cancelled) Check every single direct access to a context and add NULL pointer protection.
Ugghhhh
** DONE (Cancelled) Find every nkMalloc, nkRealloc, and nkStrdup, and make sure they all have error handling.
Blaaaaaaaaaaaaaaaagh
** DONE Make a public interface wrapper that handles all the NK_FAILURE_RECOVERY_DECL, NK_SET_FAILURE_RECOVERY*, and NK_CLEAR_FAILURE_RECOVERY crap
Call it... nkx?
** DONE Make sure all calls to stuff outside the engine get stuff properly wrapped.
Check the error status after we get back from the call. Fire off
another catastrophe if we need to.

* DONE Split everything into nkx and nki
* DONE Make errorStateAddError take a VM as a param
Mostly about cleaning up every single call in the code.
Name it nkiVmAddError.
* DONE Garbage collector should only fire off if enough objects have been created since the last run
* DONE Replace every "%u" and "%d" with NK_PRINTF_UINT32 and NK_PRINTF_INT32
* DONE Better platform detection.
16-bit vs 32-bit.
* DONE typedefs for basic types (uint32_t, etc) should have nk prefix (nk_uint32_t, etc).
Prevents us from interfering with other systems. Maintains C++
compatibility.

* DONE User-definable malloc/free replacement
