* DONE Strings
** DONE String garbage collection
* DONE Functions
** DONE VM functions
** DONE Native functions
*** DONE Native function userdata
*** DONE Check for duplicate native functions?
** DONE Calling VM functions from native functions.
* DONE For-loops
* DONE Increment and decrement operators
* DONE Comparison operators
** DONE Greater than
** DONE Less than
** DONE Greater than or equal
** DONE Less than or equal
** DONE Equal
** DONE Not equal
** DONE Equal with same type (===)
* DONE "Not" operator
* DONE % operator
* DONE && operator
* DONE || operator
* DONE Objects
** DONE Object garbage collection
** DONE Refactor objects to use hash tables.
** DONE Ability to clear values from an object.
** DONE External object handles.
* DONE Add generic hash function for Values.
* TODO Fuzz tester
* TODO External data
** TODO Index-into for external data
** TODO Operator overloading for external data
** TODO GC callbacks
* TODO State serialization
** TODO Something for recognizing the same native function between save and load
Even if the address ends up different. (For serialized state
compatibility between different architectures, for example.)
** TODO Save
** TODO Load
* TODO Configurable limits
** TODO Memory usage
*** DONE Max strings
*** DONE Max string length
*** TODO Max stack size
*** TODO Max objects
*** TODO Max fields per object
*** TODO Max allocated memory
Remember to search for all the malloc, reallocs, and strdups.
** TODO Compiler recursion limit
* TODO Documentation
Pfffffft

* TODO Can we double-buffer the GC list?
- May not be possible when we have to count external references.
* DONE foo.bar syntactic sugar.
'.' operator must be treated as postfix, I think. It's got the same
precedence level as other postfix operators, and it acts like [],
which is also postfix.

Look into the [] implementation to see how to do postfix operators
with secondary values.

a[b] is...
+ index into operator
  + a
  + b

a.b is...
+ index into operator
  + a
  + "b"

* DONE foo.bar() syntactic sugar.
We'll copy Lua here and insert a "self" parameter as the first
parameter here.

x.a(b, c) is...
+ function call (root)
  + index into operator
    + x
    + "a"
  + function call (param)
    + x
    + function call (param)
      + b
      + function call (param)
        + c
        + NULL

* TODO Deal with code duplication between string and object tables.
* DONE Maybe implement break.
- We'll have to keep track of what the most recent loop context is.
- Then add code to pop all of that out and jump to the end.
- Meaning we'll have to keep a list of jump points to update once the loop is over.
- Can store that all on the context object, I guess.
- Make sure we don't go outside the function while moving up the context stack!


* TODO Get rid of dump opcode.
