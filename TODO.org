* DONE Strings
** DONE String garbage collection
* DONE Functions
** DONE VM functions
** DONE Native functions
*** TODO Native function userdata
*** TODO Check for duplicate native functions?
** DONE Calling VM functions from native functions.
* DONE For-loops
* DONE Increment and decrement operators
* DONE Comparison operators
** DONE Greater than
** DONE Less than
** DONE Greater than or equal
** DONE Less than or equal
** DONE Equal
** DONE Not equal
** DONE Equal with same type (===)
* DONE "Not" operator
* DONE % operator
* DONE && operator
* DONE || operator
* TODO Objects
** TODO Object garbage collection
* TODO Fuzz tester
* TODO External data
* TODO State serialization
** TODO Something for recognizing the same native function between save and load
Even if the address ends up different. (For serialized state
compatibility between different architectures, for example.)
** TODO Save
** TODO Load
* TODO Configurable limits
** TODO Memory usage
*** TODO Max strings
*** TODO Max stack size
*** TODO Max objects
** TODO Compiler recursion limit
* TODO Documentation

* TODO Index-into for external data
* TODO Operator overloading for external data
* TODO Can we double-buffer the GC list?
- May not be possible when we have to count external references.
* TODO foo.bar syntactic sugar.
'.' operator must be treated as postfix, I think. It's got the same
precedence level as other postfix operators, and it acts like [],
which is also postfix.

Look into the [] implementation to see how to do postfix operators
with secondary values.

a[b] is...
+ index into operator
  + a
  + b

a.b is...
+ index into operator
  + a
  + "b"

* TODO foo.bar() syntactic sugar.
We'll copy Lua here and insert a "self" parameter as the first
parameter here.

x.a(b, c) is...
+ function call (root)
  + index into operator
    + x
    + "a"
  + function call (param)
    + x
    + function call (param)
      + b
      + function call (param)
        + c
        + NULL

* TODO Deal with code duplication between string and object tables.
* TODO Maybe increment break.
- We'll have to keep track of what the most recent loop context is.
- Then add code to pop all of that out and jump to the end.
- Meaning we'll have to keep a list of jump points to update once the loop is over.
- Can store that all on the context object, I guess.
- Make sure we don't go outside the function while moving up the context stack!


