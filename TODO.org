* DONE Strings
** DONE String garbage collection
* DONE Functions
** DONE VM functions
** DONE Native functions
*** DONE Native function userdata
*** DONE Check for duplicate native functions?
*** TODO Take out userdata
We'll just add one big userdata pointer to the VM, with a
serialization callback. This keeps us from having to manage userdata
lifetimes, because as of this writing, all the userdata is permanent
for the lifetime of the VM.
*** TODO Native function serialization
We may need a native function table of some sort, which must be
created before deserialization, compilation, or adding C functions.
Adding functions that are not in it, or deserializing and discovering
unregistered functions would probably have to be made an illegal
operation.
** DONE Calling VM functions from native functions.
* DONE For-loops
* DONE Increment and decrement operators
* DONE Comparison operators
** DONE Greater than
** DONE Less than
** DONE Greater than or equal
** DONE Less than or equal
** DONE Equal
** DONE Not equal
** DONE Equal with same type (===)
* DONE "Not" operator
* DONE % operator
* DONE && operator
* DONE || operator
* DONE Objects
** DONE Object garbage collection
** DONE Refactor objects to use hash tables.
** DONE Ability to clear values from an object.
** DONE External object handles.
* DONE Add generic hash function for Values.
* TODO Fuzz tester
* TODO External data
** TODO Index-into for external data
** TODO Operator overloading for external data
** TODO GC callbacks
* TODO State serialization
** TODO Something for recognizing the same native function between save and load
Even if the address ends up different. (For serialized state
compatibility between different architectures, for example.)
** TODO Save
** TODO Load
* TODO Configurable limits
** TODO Memory usage
*** DONE Max strings
*** DONE Max string length
*** DONE Max stack size
*** DONE Max objects
*** DONE Max fields per object
*** DONE Max allocated memory
Remember to search for all the malloc, reallocs, and strdups.
**** DONE Correctly handle errors for everything
**** DONE Make a tester that randomly starts returning NULL and see if anything breaks.
** DONE Compiler recursion limit
* TODO Documentation
Pfffffft

* TODO Can we double-buffer the GC list?
- May not be possible when we have to count external references.
* DONE foo.bar syntactic sugar.
'.' operator must be treated as postfix, I think. It's got the same
precedence level as other postfix operators, and it acts like [],
which is also postfix.

Look into the [] implementation to see how to do postfix operators
with secondary values.

a[b] is...
+ index into operator
  + a
  + b

a.b is...
+ index into operator
  + a
  + "b"

* DONE foo.bar() syntactic sugar.
We'll copy Lua here and insert a "self" parameter as the first
parameter here.

x.a(b, c) is...
+ function call (root)
  + index into operator
    + x
    + "a"
  + function call (param)
    + x
    + function call (param)
      + b
      + function call (param)
        + c
        + NULL

* TODO Deal with code duplication between string and object tables.
* DONE Maybe implement break.
- We'll have to keep track of what the most recent loop context is.
- Then add code to pop all of that out and jump to the end.
- Meaning we'll have to keep a list of jump points to update once the loop is over.
- Can store that all on the context object, I guess.
- Make sure we don't go outside the function while moving up the context stack!


* TODO Get rid of dump opcode.

* TODO Get rid of all the asserts that were ensuring contexts line up.
* TODO Make sure the error system has a standard way of reporting errors.
Looking at the structure won't work.
* DONE Looking up a nonexistant entry in an object should return nil and not create anything.
* TODO Catastrophe handling
** TODO Make sure the standard error reporting recognizes the out-of-memory special case.
** DONE (Cancelled) Check every single direct access to a context and add NULL pointer protection.
Ugghhhh
** DONE (Cancelled) Find every nkMalloc, nkRealloc, and nkStrdup, and make sure they all have error handling.
Blaaaaaaaaaaaaaaaagh
** DONE Make a public interface wrapper that handles all the NK_FAILURE_RECOVERY_DECL, NK_SET_FAILURE_RECOVERY*, and NK_CLEAR_FAILURE_RECOVERY crap
Call it... nkx?
** DONE Make sure all calls to stuff outside the engine get stuff properly wrapped.
Check the error status after we get back from the call. Fire off
another catastrophe if we need to.

* TODO Split everything into nkx and nki
* DONE Make errorStateAddError take a VM as a param
Mostly about cleaning up every single call in the code.
Name it nkiVmAddError.
* TODO Garbage collector should only fire off if enough objects have been created since the last tun
